# 1004

## 14.
- 変数の後ろに型を指定
- 型推論により全て指定しなくてよい
- 初期化する場合は型の指定が必要

## 15.
- オブジェクト型の定義
  ↓
  {
    prop1:type;
    prop2:type;
    ...
  }
- プロパティの型も指定できるが推論に任せたほうが効率的
- ネストしたオブジェクト型も定義可能

## 17.
- 単独の型による配列であれば型指定・型推論が可能
- 複数の型による配列はany型
- any型にすると型指定の恩恵を失う

## 18.
- Tuple型→長さと型を固定された配列
- 異なる長さ・型の配列を代入するとエラーになる
- Tupleはpushが許可される（エラーにならない）ことに注意

# 1005
## 19.
- Enum型→複数の定数をグループ分け
- 定数に割り振る番号・文字列を指定可能
- 指定がなければ0からカウント
- 指定した数字からカウント

## 20.
- any型はできるだけ避ける（TSでチェックを行わない）
- 基本的には推論か型を明示する

## 21.
- Union型→複数の型パイプでつないで指定
- 例） input : number | string
- 引数inputにはnumber型とstring型を受け入れる
- typeofによるチェックが必要な場合もある

## 22.
- Literal型→指定した特定の値のみを許可する型

## 23.
- エイリアス型→型に別名をつける
- 型の再利用が可能
- DRY原則（不必要な繰り返しを避ける）
- オブジェクト型のような複雑な型に名前をつけて分かりやすくする

## 25.
- 関数の戻り値も型指定・型推論が可能
- void型→関数に戻り値が存在しないことを示す（return文が不要）
- undefined型→戻り値が何も返さないことを示す（return文が必要・キホンは使わない）

## 26.
- Function型→アロー関数の形でより厳密な型指定が可能

## 27.
- コールバック関数の型指定
- 引数の型は厳密である必要がある（値を渡さなければならないため）
- 戻り値の型がvoidの場合、戻り値を期待しないということ（戻り値はあってもなくても良い）